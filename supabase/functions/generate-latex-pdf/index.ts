
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

// CORS headers for browser access
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Main handler function
serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Get report data from request
    const { report, property } = await req.json();
    
    console.log("Received request to generate PDF for property:", property.address);
    
    // Generate LaTeX content
    const latexContent = generateReportLatex(report, property);
    
    // Compile LaTeX to PDF using external service
    const pdfBase64 = await compileLatexToPdf(latexContent);
    
    // Return the PDF data
    return new Response(
      JSON.stringify({ 
        success: true, 
        pdfData: pdfBase64,
        message: "PDF successfully generated" 
      }),
      { 
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json'
        } 
      }
    );
  } catch (error) {
    console.error("Error generating PDF:", error);
    
    // Generate a simple fallback PDF using direct base64 encoding
    const fallbackPdfBase64 = generateFallbackPdf(error.message);
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        pdfData: fallbackPdfBase64,
        error: error.message,
        message: "LaTeX compilation failed, using fallback PDF" 
      }),
      { 
        status: 200, // Return 200 with fallback PDF instead of error
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json'
        } 
      }
    );
  }
});

// Function to generate LaTeX content from report data
function generateReportLatex(report, property) {
  // Start with document preamble
  let latex = `\\documentclass[12pt,a4paper]{article}
\\usepackage{graphicx}
\\usepackage{geometry}
\\usepackage{array}
\\usepackage{booktabs}
\\usepackage{colortbl}
\\usepackage{xcolor}
\\usepackage{hyperref}
\\usepackage{longtable}
\\usepackage{enumitem}
\\usepackage{fancyhdr}
\\usepackage{titlesec}

\\geometry{margin=2.5cm}
\\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}
\\setlength{\\parindent}{0pt}
\\setlength{\\parskip}{6pt}
\\pagestyle{fancy}
\\renewcommand{\\headrulewidth}{0.4pt}
\\renewcommand{\\footrulewidth}{0.4pt}

\\definecolor{headercolor}{RGB}{33, 62, 84}
\\definecolor{lightheadercolor}{RGB}{70, 130, 180}

\\begin{document}

% Cover Page
\\begin{titlepage}
\\centering
\\vspace*{1cm}
{\\color{headercolor}\\Huge\\bfseries ${report.type === "comparison" ? "Comparison Report" : "Inventory and Check In Report"} \\par}
\\vspace{2cm}
{\\LARGE ${property.address} \\par}
{\\large ${property.city}, ${property.state} ${property.zipCode} \\par}
\\vspace{1cm}

% Report Details
\\begin{tabular}{rp{8cm}}
\\textbf{Report Date:} & ${formatDate(report.reportInfo?.reportDate)} \\\\
\\textbf{Inspector:} & ${report.reportInfo?.clerk || "Not specified"} \\\\
\\textbf{Status:} & ${formatString(report.status)} \\\\
${report.reportInfo?.tenantName ? `\\textbf{Tenant:} & ${report.reportInfo.tenantName} \\\\` : ""}
\\end{tabular}

\\vfill

{\\large Generated by Share.AI Property Reports \\par}
\\end{titlepage}`;

  // Table of Contents
  latex += `
\\tableofcontents
\\newpage

% Disclaimer
\\section*{Disclaimer}
\\addcontentsline{toc}{section}{Disclaimer}
This inventory and condition report has been prepared to provide a fair and accurate record of the condition of the items included in the inventory and the property's cleanliness at the time of inspection. The report will be used as a reference at the end of the tenancy to assess any damages or cleaning requirements.

\\noindent Please note:
\\begin{itemize}
  \\item This report does not identify or comment on structural defects.
  \\item This report does not check any item for safety unless explicitly stated.
  \\item All items are assumed to be working and in good condition unless otherwise stated.
\\end{itemize}
\\newpage`;

  // Summary tables
  if (report.type !== "comparison") {
    latex += `
% Summary Tables
\\section*{Property Summary}
\\addcontentsline{toc}{section}{Property Summary}
\\begin{tabular}{|p{5cm}|p{10cm}|}
\\hline
\\rowcolor{lightheadercolor} \\textbf{Property Address} & \\textbf{Description} \\\\
\\hline
${property.address}, ${property.city} & ${property.description || "No description provided"} \\\\
\\hline
\\end{tabular}

\\vspace{1cm}

\\begin{tabular}{|p{5cm}|p{10cm}|}
\\hline
\\rowcolor{lightheadercolor} \\textbf{Item} & \\textbf{Status} \\\\
\\hline
Keys Received & ${report.reportInfo?.keysReceived ? "Yes" : "No"} \\\\
\\hline
Smoke Alarms Tested & ${report.reportInfo?.smokeAlarmsChecked ? "Yes" : "No"} \\\\
\\hline
\\end{tabular}
\\newpage`;
  }

  // Special handling for comparison report
  if (report.type === "comparison" && report.reportInfo?.comparisonText) {
    latex += `
% Comparison Section
\\section*{Property Comparison}
\\addcontentsline{toc}{section}{Property Comparison}
${report.reportInfo.comparisonText.split('\n').join(' \\\\\n')}
\\newpage`;
  } else {
    // Process each room
    if (report.rooms && report.rooms.length > 0) {
      report.rooms.forEach((room, index) => {
        latex += generateRoomLatex(room, index + 1);
      });
    }
  }

  // Add disclaimers if present
  if (report.disclaimers && report.disclaimers.length > 0) {
    latex += `
% Disclaimers
\\section*{Disclaimers}
\\addcontentsline{toc}{section}{Disclaimers}
\\begin{itemize}
${report.disclaimers.map(disclaimer => `  \\item ${disclaimer}`).join('\n')}
\\end{itemize}`;
  }

  // End document
  latex += `
\\end{document}`;

  return latex;
}

// Function to generate LaTeX for a single room
function generateRoomLatex(room, roomNumber) {
  let latex = `
% Room ${roomNumber}: ${room.name}
\\section{${room.name}}
`;

  // Room general information
  if (room.generalCondition || room.notes) {
    latex += `
\\subsection*{General Condition}
${room.generalCondition || "No general condition information provided."}

${room.notes ? `\\subsection*{Notes}\n${room.notes}` : ""}
`;
  }

  // Room images
  if (room.images && room.images.length > 0) {
    latex += `
\\subsection*{Room Images}
`;
    
    // Create a grid of images (2 per row)
    for (let i = 0; i < room.images.length; i += 2) {
      latex += `\\begin{center}\n`;
      
      // First image in the row - use placeholders for external URLs
      latex += `\\includegraphics[width=0.45\\textwidth]{example-image}`;
      
      // Second image if available
      if (i + 1 < room.images.length) {
        latex += ` \\hspace{0.05\\textwidth} \\includegraphics[width=0.45\\textwidth]{example-image}`;
      }
      
      latex += `\\end{center}\n\n`;
    }
  }

  // Components
  if (room.components && room.components.length > 0) {
    latex += `
\\subsection*{Room Components}
`;

    room.components.forEach(component => {
      latex += generateComponentLatex(component);
    });
  }

  // Add page break after room
  latex += `\\newpage\n`;

  return latex;
}

// Function to generate LaTeX for a component
function generateComponentLatex(component) {
  let latex = `
\\subsubsection*{${component.name}}

\\begin{tabular}{|p{3cm}|p{12cm}|}
\\hline
\\rowcolor{lightheadercolor} \\textbf{Attribute} & \\textbf{Details} \\\\
\\hline
Description & ${component.description || "No description provided"} \\\\
\\hline
Condition & ${component.condition?.summary || "Not assessed"} \\\\
\\hline
Cleanliness & ${formatString(component.cleanliness) || "Not assessed"} \\\\
\\hline
${component.notes ? `Notes & ${component.notes} \\\\\n\\hline` : ""}
\\end{tabular}
`;

  // Component images
  if (component.images && component.images.length > 0) {
    // Create a grid of images (2 per row)
    for (let i = 0; i < component.images.length; i += 2) {
      latex += `\\begin{center}\n`;
      
      // Use placeholder images instead of external URLs
      latex += `\\includegraphics[width=0.45\\textwidth]{example-image}`;
      
      // Second image if available
      if (i + 1 < component.images.length) {
        latex += ` \\hspace{0.05\\textwidth} \\includegraphics[width=0.45\\textwidth]{example-image}`;
      }
      
      latex += `\\end{center}\n\n`;
    }
  }

  return latex;
}

// Helper function to format string with capitalization and underscore replacement
function formatString(str) {
  if (!str) return "";
  return str.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Helper function to format date
function formatDate(dateString) {
  if (!dateString) return "Not specified";
  try {
    return new Date(dateString).toLocaleDateString();
  } catch {
    return dateString;
  }
}

// Function to compile LaTeX to PDF using a third-party API
async function compileLatexToPdf(latexContent) {
  try {
    console.log("Compiling LaTeX to PDF using improved method...");
    
    // Encode the LaTeX content properly for transmission
    const encoded = encodeURIComponent(latexContent);
    
    // Fix: Use a valid URL structure with proper protocol
    const url = new URL("https://texlive2.net/cgi-bin/latexcgi");
    url.searchParams.append("program", "pdflatex");
    url.searchParams.append("text", latexContent);
    
    console.log("Making request to LaTeX compilation service");
    
    // Use POST instead of GET for more reliable handling of large LaTeX documents
    const response = await fetch(url.toString(), {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: `program=pdflatex&text=${encoded}`,
    });
    
    if (!response.ok) {
      throw new Error(`LaTeX compilation failed with status: ${response.status}`);
    }
    
    // Get the PDF as an ArrayBuffer
    const pdfBuffer = await response.arrayBuffer();
    
    // Convert the ArrayBuffer to a base64 string
    const base64String = btoa(String.fromCharCode(...new Uint8Array(pdfBuffer)));
    
    return base64String;
  } catch (error) {
    console.error("Error in LaTeX compilation:", error);
    
    // Instead of returning a placeholder PDF, throw the error
    // to trigger the fallback PDF generation
    throw new Error(`LaTeX compilation failed: ${error.message}`);
  }
}

// Function to generate a simple fallback PDF when LaTeX fails
function generateFallbackPdf(errorMessage) {
  // This is a very simple PDF structure in base64 format
  // It contains basic information and the error message
  return "JVBERi0xLjUKJfr6/P8KMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjIgMCBvYmoKPDwKL1R5cGUgL1BhZ2VzCi9LaWRzIFszIDAgUl0KL0NvdW50IDEKPj4KZW5kb2JqCjMgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL01lZGlhQm94IFswIDAgNTk1LjI4IDg0MS44OV0KL1Jlc291cmNlcyA8PAovRm9udCA8PAovRjEgNCAwIFIKPj4KPj4KL0NvbnRlbnRzIDUgMCBSCi9QYXJlbnQgMiAwIFIKPj4KZW5kb2JqCjQgMCBvYmoKPDwKL1R5cGUgL0ZvbnQKL1N1YnR5cGUgL1R5cGUxCi9CYXNlRm9udCAvSGVsdmV0aWNhCi9FbmNvZGluZyAvV2luQW5zaUVuY29kaW5nCj4+CmVuZG9iago1IDAgb2JqCjw8Ci9MZW5ndGggMjUwCj4+CnN0cmVhbQpCVAovRjEgMTIgVGYKMTAgODMwIFRkCihUZW1wb3JhcnkgUERGIEdlbmVyYXRlZCBieSBTaGFyZS5BSSBSZXBvcnRzKSBUagoxMCA4MDAgVGQKKFRoZXJlIHdhcyBhbiBlcnJvciBnZW5lcmF0aW5nIHlvdXIgTGFUZVggUERGLiBQbGVhc2UgdHJ5IGFnYWluLikgVGoKMTAgNzgwIFRkCihFcnJvcjogKSBUagoxMCA3NjAgVGQKKExhVGVYIGNvbXBpbGF0aW9uIHNlcnZpY2UgZW5jb3VudGVyZWQgYSBwcm9ibGVtLikgVGoKRVQKZW5kc3RyZWFtCmVuZG9iago2IDAgb2JqCjw8Ci9Qcm9kdWNlciAoU2hhcmUuQUkgUERGIEdlbmVyYXRvcikKPj4KZW5kb2JqCnhyZWYKMCA3CjAwMDAwMDAwMDAgNjU1MzUgZg0KMDAwMDAwMDAxNSAwMDAwMCBuDQowMDAwMDAwMDY2IDAwMDAwIG4NCjAwMDAwMDAxMjMgMDAwMDAgbg0KMDAwMDAwMDI3MCAwMDAwMCBuDQowMDAwMDAwMzY3IDAwMDAwIG4NCjAwMDAwMDA2NjUgMDAwMDAgbg0KdHJhaWxlcgo8PAovU2l6ZSA3Ci9Sb290IDEgMCBSCi9JbmZvIDYgMCBSCj4+CnN0YXJ0eHJlZgo3MTgKJSVFT0Y=";
}
